import pandas as pd
from sklearn.neural_network import MLPClassifier
import numpy as np

from main_classificator import ct
from main_classificator.preprocessing.preproc_data import prepare_train_dataset_pipeline, \
    read_batches_from_test_preprocessed, get_x


def small_batch_classificator():
    X, Y = prepare_train_dataset_pipeline()
    len_of_bytes = len(X[0])
    clf = simple_model(X, Y, hidden_layers_size=(len_of_bytes,
                                                 int(len_of_bytes*0.8),
                                                 int(len_of_bytes*0.6),
                                                 int(len_of_bytes*0.4),
                                                 int(len_of_bytes*0.2),
                                                 int(len_of_bytes*0.1),
                                                 5))
    X_test = None


def aggregate_results(df: pd.DataFrame) -> pd.DataFrame:
    assert ct.PREDICTION_COLUMN in df.columns and ct.ID_COLUMN in df.columns

    # TODO: use a classificator here to get the result classification
    """
    in that classificator you should p
    """

    def proc_groups(name, group):
        return pd.DataFrame({ct.ID_COLUMN: [name],
                             ct.PREDICTION_COLUMN: [sum(np.array(list(group[ct.PREDICTION_COLUMN].values))) / len(group)]})

    df = pd.concat([proc_groups(name, group) for name, group in df.groupby([ct.ID_COLUMN])])
    return df


def predict_large(clf):
    result_df = pd.DataFrame()
    for df in read_batches_from_test_preprocessed(list(range(ct.NUM_OF_TEST_BATCHES))):
        X_test = get_x(df)
        df[ct.PREDICTION_COLUMN] = clf.predict(X_test)
        # TODO: use clf.predict_proba()
        result_df = pd.concat([result_df, aggregate_results(df)])


def simple_model(X, Y, hidden_layers_size = (5,2)):
    clf = MLPClassifier(solver='lbfgs', alpha=1e-5,
                        hidden_layer_sizes=hidden_layers_size, random_state=1)

    clf.fit(X, Y)
    return clf


def simple_example():
    from random import randint
    # X_train = [[-1., -2.]]
    # y = [0]
    X_train = []
    y = []

    for i in range(100):
        x_ = randint(-10, 10)
        y_ = randint(-10, 10)
        X_train.append([x_, y_])
        if y_ == x_:
            y.append(2)
        else:
            y.append(int(y_ - x_ > 0))

    clf = simple_model(X_train, Y=y, hidden_layers_size=(5, 5, 5))

    X_test = [[0., 0.], [-1., -2.], [-2., -1.], [-1., -1.], [2., 1.]]
    prediction = clf.predict(X_test)
    y_test = [2, 0, 1, 2, 0]
    print(f"prediction result = {prediction}: result is correct - {np.array_equal(prediction, np.array(y_test))}")


if __name__ == '__main__':
    simple_example()
