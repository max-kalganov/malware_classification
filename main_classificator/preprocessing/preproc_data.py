from typing import Mapping

from main_classificator import ct
from random import shuffle
import numpy as np

from main_classificator.preprocessing.files_manipulation import get_all_file_names, read_data_from_files
from main_classificator.utils import Extention, get_file_name_by_extention


def read_data_in_dict(path_to_folder: str,
                 num_of_files: int = None,
                 ext: Extention = None,
                 shuffle_list: bool = False) -> Mapping[str, str]:
    file_names = get_all_file_names(path_to_folder)

    if ext:
        file_names = get_file_name_by_extention(file_names, ext)

    if shuffle_list:
        shuffle(file_names)

    if num_of_files:
        assert num_of_files > 0, f"wrong num of files = {num_of_files}"
        file_names = file_names[:num_of_files]

    all_data = read_data_from_files(file_names)
    return all_data


def transform_bytes_into_np_array(all_data: Mapping[str, str]) -> Mapping[str, np.array]:
    def get_bytes(byte_file: str) -> np.array:
        """

        :param byte_file: str with bytes from file
            template for a row - num_of_a_rowI byte1 byte2 ... byteN\n

            delimeters:
            \n - for rows
            ' ' - for bytes and num of row
        :return:
            for each file_name will be np.array with bytes. -1 is representing QM '?', next num - num of ? goes next
        """

        rows = [cutted_row.split(' ')[1:] for cutted_row in byte_file.split('\n')]
        just_bytes = []
        [just_bytes.extend(r) for r in rows]
        int_bytes = []
        num_of_QM = 0

        for byte in just_bytes:
            if '?' not in byte:
                if num_of_QM != 0:
                    int_bytes.append(-1)
                    int_bytes.append(num_of_QM)
                    num_of_QM = 0

                int_byte = int(byte, 16)
                int_bytes.append(int_byte)
            else:
                num_of_QM += 1

        return np.array(int_bytes)

    transformed_data = {}
    for k, v in all_data.items():
        transformed_data[k] = get_bytes(v)
    return transformed_data


if __name__ == '__main__':
    all_data = read_data_in_dict(path_to_folder=ct.get_path_to_train_cut_folder(),
                                 num_of_files=3,
                                 ext=Extention.BYTES,
                                 shuffle_list=True)
    np_data = transform_bytes_into_np_array(all_data)
    for k, v in np_data.items():
        print(f"{k} --  {v[:20]} -- {all_data[k].split(' ')[:20]}")
        print(f" all_data len = {len(all_data[k])}, res_data len = {len(np_data[k])}, "
              f"len_all_data / len_res_data = {len(all_data[k])/len(np_data[k])}")
